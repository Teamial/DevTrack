"use strict";var V=Object.create;var E=Object.defineProperty;var X=Object.getOwnPropertyDescriptor;var ee=Object.getOwnPropertyNames;var te=Object.getPrototypeOf,ie=Object.prototype.hasOwnProperty;var re=(c,e)=>{for(var t in e)E(c,t,{get:e[t],enumerable:!0})},B=(c,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of ee(e))!ie.call(c,r)&&r!==t&&E(c,r,{get:()=>e[r],enumerable:!(i=X(e,r))||i.enumerable});return c};var f=(c,e,t)=>(t=c!=null?V(te(c)):{},B(e||!c||!c.__esModule?E(t,"default",{value:c,enumerable:!0}):t,c)),ae=c=>B(E({},"__esModule",{value:!0}),c);var se={};re(se,{activate:()=>oe,deactivate:()=>ne});module.exports=ae(se);var s=f(require("vscode"));var I=require("@octokit/rest"),$=f(require("vscode")),P=class{constructor(e){this.token="";this.outputChannel=e}setToken(e){this.token=e,this.octokit=new I.Octokit({auth:this.token})}async createRepo(e,t="DevTrack Repository"){try{return(await this.octokit.repos.createForAuthenticatedUser({name:e,description:t,private:!1})).data.clone_url}catch(i){return this.outputChannel.appendLine(`Error creating repository: ${i.message}`),$.window.showErrorMessage(`DevTrack: Failed to create repository "${e}".`),null}}async repoExists(e){try{let t=await this.getUsername();return t?(await this.octokit.repos.get({owner:t,repo:e}),!0):($.window.showErrorMessage("DevTrack: Unable to retrieve GitHub username."),!1)}catch(t){return t.status===404||$.window.showErrorMessage(`DevTrack: Error checking repository "${e}".`),!1}}async getUsername(){try{let{data:e}=await this.octokit.users.getAuthenticated();return e.login}catch(e){return this.outputChannel.appendLine(`Error fetching username: ${e.message}`),$.window.showErrorMessage("DevTrack: Unable to fetch GitHub username."),null}}};var O=f(require("simple-git")),h=f(require("vscode")),v=f(require("path")),N=require("minimatch"),z=require("events"),q=f(require("fs")),F=class extends z.EventEmitter{constructor(e){super(),this.outputChannel=e;let t=h.workspace.workspaceFolders;if(!t||t.length===0)throw new Error("No workspace folder open.");let i=t[0].uri.fsPath;if(this.repoPath=i,this.trackingDirectory=v.join(this.repoPath,".devtrack"),this.initialCommitTimestamp=Date.now(),!v.isAbsolute(this.repoPath))throw new Error("Invalid repository path.");this.git=(0,O.default)(this.repoPath)}async initializeRepo(e){try{if(!await this.git.checkIsRepo())await this.git.init(),this.outputChannel.appendLine("DevTrack: Initialized new Git repository.");else if(await this.isDevTrackRepo()){this.outputChannel.appendLine("DevTrack: Repository already initialized.");return}await this.setupInitialConfig(e)}catch(t){throw this.outputChannel.appendLine(`DevTrack: Failed to initialize Git repository. ${t.message}`),t}}async isDevTrackRepo(){try{let e=v.join(this.repoPath,".devtrack");return await h.workspace.fs.stat(h.Uri.file(e)),!0}catch{return!1}}async configureRemote(e){try{let i=(await this.git.getRemotes(!0)).find(r=>r.name==="origin");i?i.refs.fetch!==e?(await this.git.removeRemote("origin"),this.outputChannel.appendLine("DevTrack: Removed existing remote origin."),await this.git.addRemote("origin",e),this.outputChannel.appendLine(`DevTrack: Added remote origin ${e}.`)):this.outputChannel.appendLine("DevTrack: Remote origin is already set correctly."):(await this.git.addRemote("origin",e),this.outputChannel.appendLine(`DevTrack: Added remote origin ${e}.`))}catch(t){throw new Error(`Failed to configure remote: ${t.message}`)}}async setupMainBranch(){try{let e=await this.git.branchLocal();!e.current||e.current!=="main"?(await this.git.checkoutLocalBranch("main"),this.outputChannel.appendLine('DevTrack: Created and switched to branch "main".')):this.outputChannel.appendLine("DevTrack: Already on main branch.")}catch(e){throw new Error(`Failed to setup main branch: ${e.message}`)}}async setupInitialConfig(e){try{await this.setupGitignore(),await this.setupDevTrackDirectory(),await this.configureRemote(e),await this.setupMainBranch(),await this.createInitialCommit(),await this.git.push(["-u","origin","main"]),this.outputChannel.appendLine("DevTrack: Initial setup completed successfully.")}catch(t){throw new Error(`Failed to set up initial configuration: ${t.message}`)}}async setupGitignore(){let e=v.join(this.repoPath,".gitignore"),t=["node_modules/","dist/",".DS_Store","build/","coverage/",".env","*.log",".vscode/","temp/","*.tmp"].join(`
`);await h.workspace.fs.writeFile(h.Uri.file(e),Uint8Array.from(Buffer.from(t,"utf8")))}async setupDevTrackDirectory(){await h.workspace.fs.createDirectory(h.Uri.file(this.trackingDirectory));let e=v.join(this.trackingDirectory,"README.md"),t=`# DevTrack Activity Log

This directory is managed by DevTrack to track your coding activity.
Only files modified after ${new Date(this.initialCommitTimestamp).toLocaleString()} will be tracked.

## Configuration
- Commit Frequency: ${h.workspace.getConfiguration("devtrack").get("commitFrequency")} minutes
- Excluded Patterns: ${JSON.stringify(h.workspace.getConfiguration("devtrack").get("exclude"))}
`;await h.workspace.fs.writeFile(h.Uri.file(e),Buffer.from(t,"utf8"))}async createInitialCommit(){try{await this.git.add([".gitignore",".devtrack/README.md"]),await this.git.commit("DevTrack: Initialize repository tracking"),this.outputChannel.appendLine("DevTrack: Created initial configuration commit.")}catch(e){throw new Error(`Failed to create initial commit: ${e.message}`)}}async commitAndPush(e){try{let t=await this.getModifiedFiles();if(t.length===0){this.outputChannel.appendLine("DevTrack: No tracked changes to commit.");return}await this.git.checkout("main");try{await this.git.pull("origin","main",{"--rebase":"true"})}catch{this.outputChannel.appendLine("DevTrack: No remote changes to pull.")}let i=0;for(let r of t)try{await this.git.add(r),i++}catch(o){this.outputChannel.appendLine(`DevTrack: Could not stage file ${r}: ${o}`)}if(i===0){this.outputChannel.appendLine("DevTrack: No files were staged for commit.");return}await this.git.commit(e),await this.git.push("origin","main"),this.emit("commit",e),this.outputChannel.appendLine(`DevTrack: Successfully committed and pushed: "${e}"`)}catch(t){this.outputChannel.appendLine(`DevTrack: Git commit failed. ${t.message}`),h.window.showErrorMessage(`DevTrack: Git commit failed. ${t.message}`)}}isTrackedFileType(e){let t=v.extname(e).toLowerCase().slice(1),i=new Set(["ts","js","py","java","c","cpp","h","hpp","css","scss","html","jsx","tsx","vue","php","rb","go","rs","swift","md","json","yml","yaml"]);if(t==="html")try{let r=h.workspace.workspaceFolders;if(!r)return!1;let o=v.resolve(e);return r.some(a=>o.startsWith(a.uri.fsPath))}catch{return!1}return i.has(t)}async getModifiedFiles(){try{let e=await this.git.status(),i=h.workspace.getConfiguration("devtrack").get("exclude")||[],r=h.workspace.workspaceFolders;if(!r)return[];let o=r[0].uri.fsPath;return e.files.filter(a=>{let n=i.some(d=>(0,N.minimatch)(a.path,d,{dot:!0})),g=a.path.startsWith(".devtrack/")||a.path===".gitignore",w=v.join(this.repoPath,a.path),k=w.startsWith(o),y=a.index==="D"||a.working_dir==="D",T=this.isTrackedFileType(a.path),p=!0;if(!y)try{p=q.existsSync(w)}catch{p=!1}return!n&&!g&&k&&(y||p)}).map(a=>a.path)}catch(e){return this.outputChannel.appendLine(`DevTrack: Error getting modified files: ${e}`),[]}}};var G=f(require("vscode")),W=require("events"),_=require("minimatch"),R=class extends W.EventEmitter{constructor(t){super();this.changes=new Map;this.excludePatterns=[];this.outputChannel=t,this.initializeWatcher()}initializeWatcher(){let t=G.workspace.getConfiguration("devtrack");this.excludePatterns=t.get("exclude")||[],this.watcher=G.workspace.createFileSystemWatcher("**/*",!1,!1,!1),this.watcher.onDidChange(i=>this.handleChange(i,"changed")),this.watcher.onDidCreate(i=>this.handleChange(i,"added")),this.watcher.onDidDelete(i=>this.handleChange(i,"deleted")),this.outputChannel.appendLine("DevTrack: File system watcher initialized.")}handleChange(t,i){var r;try{let o=G.workspace.asRelativePath(t);if(!this.excludePatterns.some(n=>(0,_.minimatch)(o,n))){let n=(r=t.fsPath.split(".").pop())==null?void 0:r.toLowerCase();if(n&&["ts","js","py","java","c","cpp","h","hpp","css","scss","html","jsx","tsx","vue","php","rb","go","rs","swift","md","json","yml","yaml"].includes(n)){let w=t.fsPath,k=this.changes.get(w);k&&(k.type==="deleted"&&i==="added"||k.type==="added"&&i==="changed")&&(i="added");let y={uri:t,timestamp:new Date,type:i};this.changes.set(w,y),this.emit("change",y),this.outputChannel.appendLine(`DevTrack: Detected ${i} in ${o}`)}}}catch(o){this.outputChannel.appendLine(`DevTrack: Error handling file change: ${o}`)}}getChangedFiles(){return Array.from(this.changes.values())}clearChanges(){this.changes.clear(),this.outputChannel.appendLine("DevTrack: Cleared tracked changes.")}updateExcludePatterns(t){this.excludePatterns=t,this.outputChannel.appendLine("DevTrack: Updated exclude patterns.")}dispose(){this.watcher.dispose(),this.outputChannel.appendLine("DevTrack: Disposed file system watcher.")}};var Y=f(require("vscode")),J=f(require("path"));var x=f(require("vscode")),M=f(require("path")),j=class{constructor(e,t){this.commitHistory=[];this.projectStats={mostChangedFiles:new Map,recentMilestones:[],activeBranch:"",lastCommitTime:new Date};this.outputChannel=e,this.extensionContext=t,this.loadContext()}async loadContext(){try{await this.loadGitHistory(),await this.updateProjectStats(),this.outputChannel.appendLine("DevTrack: Loaded project context")}catch(e){this.outputChannel.appendLine(`DevTrack: Error loading context: ${e}`)}}async loadGitHistory(){try{let e=x.extensions.getExtension("vscode.git");if(e){let t=e.exports.getAPI(1);if(t.repositories.length>0){let r=await t.repositories[0].log({maxEntries:50});this.commitHistory=r.map(o=>{var a;return{timestamp:o.commitDate.getTime(),summary:o.message,files:((a=o.files)==null?void 0:a.map(n=>x.workspace.asRelativePath(n.uri)))||[],hash:o.hash}})}}}catch(e){this.outputChannel.appendLine(`DevTrack: Error loading git history: ${e}`)}}shouldTrackFile(e){let t=["node_modules",".git",".DS_Store","dist","out","build",".vscode"],i=M.extname(e).toLowerCase().slice(1),r=["ts","js","py","java","c","cpp","h","hpp","css","scss","html","jsx","tsx","vue","php","rb","go","rs","swift","md","json","yml","yaml"];return!t.some(o=>e.includes(o))&&!!i&&r.includes(i)}async addCommit(e,t){try{let i=t.map(o=>x.workspace.asRelativePath(o.uri)).filter(o=>this.shouldTrackFile(o)),r={timestamp:Date.now(),summary:e,files:i};await this.loadGitHistory(),await this.updateProjectStats()}catch(i){this.outputChannel.appendLine(`DevTrack: Error adding commit: ${i}`)}}async updateProjectStats(){var e,t;try{let i=new Map;this.commitHistory.forEach(a=>{a.files.forEach(n=>{if(this.shouldTrackFile(n)){let g=i.get(n)||0;i.set(n,g+1)}})});let r=new Map([...i.entries()].sort((a,n)=>n[1]-a[1]).slice(0,10)),o="";try{let a=x.extensions.getExtension("vscode.git");if(a){let n=a.exports.getAPI(1);n.repositories.length>0&&(o=((e=n.repositories[0].state.HEAD)==null?void 0:e.name)||"")}}catch(a){this.outputChannel.appendLine(`DevTrack: Error getting git branch: ${a}`)}this.projectStats={mostChangedFiles:r,recentMilestones:[],activeBranch:o,lastCommitTime:new Date(((t=this.commitHistory[0])==null?void 0:t.timestamp)||Date.now())}}catch(i){this.outputChannel.appendLine(`DevTrack: Error updating project stats: ${i}`)}}getContextForSummary(e){let t="";try{let i=e.map(r=>M.basename(r.uri.fsPath)).filter((r,o,a)=>a.indexOf(r)===o);i.length>0&&(t+=`Files: ${i.join(", ")}. `),this.projectStats.activeBranch&&(t+=`[${this.projectStats.activeBranch}] `)}catch(i){this.outputChannel.appendLine(`DevTrack: Error generating context summary: ${i}`)}return t}};var H=class{constructor(e,t){this.outputChannel=e,this.projectContext=new j(e,t)}async getFileChanges(e){try{let t=e.type==="added"?void 0:e.uri,i=e.type==="deleted"?void 0:e.uri;if(!t&&!i)return"";let r=Y.extensions.getExtension("vscode.git");if(!r)return"";let o=r.exports.getAPI(1);if(!o.repositories.length)return"";let n=await o.repositories[0].diff(t,i);return this.parseDiff(n,J.basename(e.uri.fsPath))}catch(t){return this.outputChannel.appendLine(`Error getting file changes: ${t}`),""}}parseDiff(e,t){if(!e)return t;let i=e.split(`
`),r={modified:new Set,added:new Set,removed:new Set},o="";for(let n of i){if(!n.trim()||n.match(/^[\+\-]\s*\/\//))continue;let g=n.match(/^([\+\-])\s*(async\s+)?((function|class|const|let|var)\s+)?([a-zA-Z_$][a-zA-Z0-9_$]*)/);if(g){let[w,k,y,T,p,d]=g;k==="+"?r.added.add(d):k==="-"&&r.removed.add(d),r.added.has(d)&&r.removed.has(d)&&(r.modified.add(d),r.added.delete(d),r.removed.delete(d));continue}}let a=[];return r.modified.size>0&&a.push(`modified ${Array.from(r.modified).join(", ")}`),r.added.size>0&&a.push(`added ${Array.from(r.added).join(", ")}`),r.removed.size>0&&a.push(`removed ${Array.from(r.removed).join(", ")}`),a.length>0?`${t} (${a.join("; ")})`:t}async generateSummary(e){try{let i=(await Promise.all(e.map(a=>this.getFileChanges(a)))).filter(Boolean),r=this.projectContext.getContextForSummary(e),o="DevTrack:";if(r&&(o+=` ${r}`),i.length>0)o+=` | Changes in: ${i.join("; ")}`;else{let a=this.calculateChangeStats(e),n=[];a.added>0&&n.push(`${a.added} files added`),a.modified>0&&n.push(`${a.modified} files modified`),a.deleted>0&&n.push(`${a.deleted} files deleted`),o+=` | ${n.join(", ")}`}return await this.projectContext.addCommit(o,e),this.outputChannel.appendLine(`DevTrack: Generated commit summary: "${o}"`),o}catch(t){return this.outputChannel.appendLine(`DevTrack: Error generating summary: ${t}`),"DevTrack: Updated files"}}calculateChangeStats(e){return{added:e.filter(t=>t.type==="added").length,modified:e.filter(t=>t.type==="changed").length,deleted:e.filter(t=>t.type==="deleted").length}}};var U=require("vscode"),S=class{constructor(e,t,i,r,o){this.timer=null;this.commitFrequency=e,this.tracker=t,this.summaryGenerator=i,this.gitService=r,this.outputChannel=o}start(){this.timer&&clearInterval(this.timer),this.timer=setInterval(()=>this.commitChanges(),this.commitFrequency*60*1e3),this.outputChannel.appendLine(`Scheduler: Started with a frequency of ${this.commitFrequency} minutes.`)}stop(){this.timer&&(clearInterval(this.timer),this.timer=null,this.outputChannel.appendLine("Scheduler: Stopped."))}async commitChanges(){let e=this.tracker.getChangedFiles();if(e.length===0){this.outputChannel.appendLine("Scheduler: No changes detected.");return}let t=await this.summaryGenerator.generateSummary(e);if(U.workspace.getConfiguration("devtrack").get("confirmBeforeCommit",!0)&&await U.window.showInformationMessage(`DevTrack: A commit will be made with the following message:
"${t}"`,{modal:!0},"Proceed","Cancel")!=="Proceed"){this.outputChannel.appendLine("Scheduler: Commit canceled by the user.");return}try{await this.gitService.commitAndPush(t),this.tracker.clearChanges(),this.outputChannel.appendLine(`Scheduler: Committed changes with message "${t}".`)}catch{this.outputChannel.appendLine("Scheduler: Failed to commit changes.")}}updateFrequency(e){this.commitFrequency=e,this.start(),this.outputChannel.appendLine(`Scheduler: Updated commit frequency to ${e} minutes.`)}};async function oe(c){let e=s.window.createOutputChannel("DevTrack");c.subscriptions.push(e),e.appendLine("DevTrack: Extension activated.");let t=new P(e),i=new F(e),r=new R(e),o=new H(e,c),a=s.workspace.getConfiguration("devtrack"),n=a.get("repoName")||"code-tracking",g=a.get("commitFrequency")||30,w=a.get("exclude")||[],k=a.get("confirmBeforeCommit")||!0;if(e.appendLine(`DevTrack Configuration:
    Repository Name: ${n}
    Commit Frequency: ${g} minutes
    Exclude Patterns: ${w.join(", ")||"None"}
    Confirm Before Commit: ${k}
  `),!n||n.trim()===""){s.window.showErrorMessage("DevTrack: Repository name is not set correctly in the configuration."),e.appendLine("DevTrack: Repository name is missing or invalid.");return}e.appendLine(`DevTrack: Using repository name "${n}".`);let y=s.authentication,T,p=s.window.createStatusBarItem(s.StatusBarAlignment.Right,100);p.text="$(circle-slash) DevTrack: Stopped",p.tooltip="DevTrack: Tracking is stopped",p.show(),c.subscriptions.push(p);let d=s.window.createStatusBarItem(s.StatusBarAlignment.Right,101);d.text="$(mark-github) DevTrack: Not Connected",d.tooltip="DevTrack Status",d.show(),c.subscriptions.push(d);let u=null;async function Z(){if(await s.window.showWarningMessage("Are you sure you want to logout from DevTrack?",{modal:!0},"Yes","No")!=="Yes"){e.appendLine("DevTrack: Logout canceled by user.");return}t.setToken(""),d.text="$(mark-github) DevTrack: Not Connected",d.tooltip="DevTrack Status",p.text="$(circle-slash) DevTrack: Stopped",p.tooltip="DevTrack: Tracking is stopped",u&&(u.stop(),u=null,e.appendLine("DevTrack: Scheduler stopped due to logout.")),await s.window.showInformationMessage("DevTrack: Successfully logged out. Would you like to log in with a different account?","Yes","No")==="Yes"&&s.commands.executeCommand("devtrack.login"),e.appendLine("DevTrack: User logged out.")}try{if(T=await y.getSession("github",["repo","read:user"],{createIfNone:!1}),T){e.appendLine("DevTrack: Using existing GitHub session."),d.text="$(check) DevTrack: Connected",d.tooltip="DevTrack is connected to GitHub",t.setToken(T.accessToken);let m=await t.getUsername();if(!m){s.window.showErrorMessage("DevTrack: Unable to retrieve GitHub username. Please ensure your token is valid."),e.appendLine("DevTrack: Unable to retrieve GitHub username.");return}e.appendLine(`Authenticated GitHub Username: ${m}`);let D=await t.repoExists(n),C=`https://github.com/${m}/${n}.git`;if(D)e.appendLine(`DevTrack: Repository "${n}" already exists.`);else{let l=await t.createRepo(n);if(l)C=l,e.appendLine(`DevTrack: Created new repository at ${C}`);else{s.window.showErrorMessage("DevTrack: Failed to create GitHub repository."),e.appendLine("DevTrack: Failed to create GitHub repository.");return}}try{await i.initializeRepo(C)}catch{e.appendLine("DevTrack: Failed to initialize Git repository.");return}u=new S(g,r,o,i,e),u.start(),e.appendLine("DevTrack: Scheduler started."),p.text="$(clock) DevTrack: Tracking",p.tooltip="DevTrack: Tracking your coding activity is active",i.on("commit",l=>{let L=new Date;p.text=`$(check) Last Commit: ${L.toLocaleTimeString()}`,e.appendLine(`DevTrack: Last commit at ${L.toLocaleTimeString()} with message: "${l}"`)})}else d.text="$(mark-github) DevTrack: Not Connected",d.tooltip="DevTrack Status",await s.window.showInformationMessage("DevTrack needs to be connected to GitHub to start tracking. Would you like to connect now?","Yes","No")==="Yes"&&s.commands.executeCommand("devtrack.login");let b=s.commands.registerCommand("devtrack.startTracking",()=>{u?(u.start(),p.text="$(clock) DevTrack: Tracking",p.tooltip="DevTrack: Tracking your coding activity is active",s.window.showInformationMessage("DevTrack: Tracking started."),e.appendLine("DevTrack: Tracking started manually.")):(s.window.showErrorMessage("DevTrack: Please connect to GitHub first."),e.appendLine("DevTrack: Scheduler is not initialized."))}),A=s.commands.registerCommand("devtrack.stopTracking",()=>{u?(u.stop(),p.text="$(circle-slash) DevTrack: Stopped",p.tooltip="DevTrack: Tracking is stopped",s.window.showInformationMessage("DevTrack: Tracking stopped."),e.appendLine("DevTrack: Tracking stopped manually.")):(s.window.showErrorMessage("DevTrack: Please connect to GitHub first."),e.appendLine("DevTrack: Scheduler is not initialized."))}),K=s.commands.registerCommand("devtrack.login",async()=>{try{if(t.setToken(""),T=await y.getSession("github",["repo","read:user"],{forceNewSession:!0}),T){t.setToken(T.accessToken);let m=await t.getUsername();if(m){s.window.showInformationMessage(`DevTrack: Connected as ${m}`),e.appendLine(`DevTrack: Connected as ${m}`),d.text="$(check) DevTrack: Connected",d.tooltip="DevTrack is connected to GitHub";let D=await t.repoExists(n),C=`https://github.com/${m}/${n}.git`;if(D)e.appendLine(`DevTrack: Repository "${n}" already exists.`);else{let l=await t.createRepo(n);if(l)C=l,e.appendLine(`DevTrack: Created new repository at ${C}`);else{s.window.showErrorMessage("DevTrack: Failed to create GitHub repository."),e.appendLine("DevTrack: Failed to create GitHub repository.");return}}try{await i.initializeRepo(C)}catch{e.appendLine("DevTrack: Failed to initialize Git repository.");return}u=new S(g,r,o,i,e),u.start(),e.appendLine("DevTrack: Scheduler started."),p.text="$(clock) DevTrack: Tracking",p.tooltip="DevTrack: Tracking your coding activity is active"}else s.window.showErrorMessage("DevTrack: Unable to retrieve GitHub username."),e.appendLine("DevTrack: Unable to retrieve GitHub username.")}else e.appendLine("DevTrack: GitHub connection canceled.")}catch(m){e.appendLine(`DevTrack: GitHub connection failed. ${m}`),s.window.showErrorMessage("DevTrack: GitHub connection failed.")}}),Q=s.commands.registerCommand("devtrack.logout",async()=>{await Z()});c.subscriptions.push(A,b,K,Q),s.workspace.onDidChangeConfiguration(async m=>{if(m.affectsConfiguration("devtrack")){let D=s.workspace.getConfiguration("devtrack"),C=D.get("repoName")||"code-tracking",l=D.get("commitFrequency")||30,L=D.get("exclude")||[],ce=D.get("confirmBeforeCommit")||!0;e.appendLine("DevTrack: Configuration updated."),u&&l!==g&&(u.updateFrequency(l),e.appendLine(`DevTrack: Commit frequency updated to ${l} minutes.`)),r&&JSON.stringify(L)!==JSON.stringify(w)&&(r.updateExcludePatterns(L),e.appendLine("DevTrack: Exclude patterns updated.")),C!==n&&(s.window.showWarningMessage("DevTrack: Repository name changed. Please restart the extension to apply changes."),e.appendLine("DevTrack: Repository name changed."))}})}catch(b){e.appendLine(`DevTrack: GitHub authentication failed. ${b}`),s.window.showErrorMessage("DevTrack: GitHub authentication failed.")}}function ne(){}0&&(module.exports={activate,deactivate});
